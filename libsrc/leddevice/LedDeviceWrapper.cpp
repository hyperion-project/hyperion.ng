#include <leddevice/LedDeviceWrapper.h>

#include <mutex>

#include <leddevice/LedDevice.h>
#include <leddevice/LedDeviceFactory.h>

// following file is auto generated by cmake! it contains all available leddevice headers
#include "LedDevice_headers.h"

// util
#include <hyperion/Hyperion.h>
#include <utils/JsonUtils.h>

// qt
#include <QtGlobal>
#include <QThread>
#include <QDir>
#include <QEventLoop>

LedDeviceRegistry LedDeviceWrapper::_ledDeviceMap {};
static std::once_flag initFlag;

LedDeviceWrapper::LedDeviceWrapper(const QSharedPointer<Hyperion>& hyperionInstance)
	: QObject()
	, _log(nullptr)
	, _hyperionWeak(hyperionInstance)
	, _ledDevice(nullptr)
	, _isEnabled(false)
	, _isOn(false)
{
	QString subComponent{ "__" };

	QSharedPointer<Hyperion> const hyperion = _hyperionWeak.toStrongRef();
	if (hyperion)
	{
		subComponent = hyperion->property("instance").toString();

		hyperion->setNewComponentState(hyperion::COMP_LEDDEVICE, false);
	}
	_log = Logger::getInstance("LEDDEVICE", subComponent);

	
}

LedDeviceWrapper::~LedDeviceWrapper()
{
	qDebug() << "LedDeviceWrapper::~LedDeviceWrapper()...";
}

void LedDeviceWrapper::createLedDevice(const QJsonObject& config)
{
	if (_ledDevice != nullptr)
	{
		stopDevice();
	}

	_ledDeviceThread.reset(new QThread());
	_ledDeviceThread->setObjectName("LedDeviceThread");
	_ledDevice.reset(LedDeviceFactory::construct(config));
	_ledDevice->setLogger(_log);

	_ledDevice->moveToThread(_ledDeviceThread.get());

	connect(_ledDeviceThread.get(), &QThread::started, _ledDevice.get(), &LedDevice::start);
	connect(this, &LedDeviceWrapper::updateLeds, _ledDevice.get(), &LedDevice::updateLeds);
	connect(this, &LedDeviceWrapper::switchOn, _ledDevice.get(), &LedDevice::switchOn);
	connect(this, &LedDeviceWrapper::switchOff, _ledDevice.get(), &LedDevice::switchOff);
	connect(this, &LedDeviceWrapper::enable, _ledDevice.get(), &LedDevice::enable);
	connect(this, &LedDeviceWrapper::disable, _ledDevice.get(), &LedDevice::disable);
	connect(this, &LedDeviceWrapper::stop, _ledDevice.get(), &LedDevice::stop );

	//Handle LED-device state changes
	connect(_ledDevice.get(), &LedDevice::isEnabledChanged, this, &LedDeviceWrapper::onIsEnabledChanged);
	connect(_ledDevice.get(), &LedDevice::isOnChanged, this, &LedDeviceWrapper::onIsOnChanged);

	_ledDeviceThread->start();
}

void LedDeviceWrapper::handleComponentState(hyperion::Components component, bool state)
{
	if (component == hyperion::COMP_LEDDEVICE)
	{
		if (state)
		{
			emit enable();
		}
		else
		{
			emit disable();
		}
	}
}

void LedDeviceWrapper::onIsEnabledChanged(bool isEnabled)
{
	QSharedPointer<Hyperion> const hyperion = _hyperionWeak.toStrongRef();
	if (hyperion)
	{
		hyperion->setNewComponentState(hyperion::COMP_LEDDEVICE, isEnabled);
	}
	_isEnabled = isEnabled;
}

void LedDeviceWrapper::onIsOnChanged(bool isOn)
{
	_isOn = isOn;
	if (_isOn)
	{
		QSharedPointer<Hyperion> const hyperion = _hyperionWeak.toStrongRef();
		if (hyperion)
		{
			hyperion->refreshUpdate();
		}
	}
}

void LedDeviceWrapper::stopDevice()
{
	Debug(_log, "Stop LED-Device thread");

	//Disable updates to the LedDevice
	disconnect(this, &LedDeviceWrapper::updateLeds, _ledDevice.get(), &LedDevice::updateLeds);
	disconnect(this, &LedDeviceWrapper::switchOff, _ledDevice.get(), &LedDevice::switchOff);
	disconnect(this, &LedDeviceWrapper::disable, _ledDevice.get(), &LedDevice::disable);
	disconnect(this, &LedDeviceWrapper::enable, _ledDevice.get(), &LedDevice::enable);
	disconnect(this, &LedDeviceWrapper::switchOn, _ledDevice.get(), &LedDevice::switchOn);

	// Create a local event loop to wait for the LedDevice isStopped signal
	QEventLoop loop;
	connect(_ledDevice.get(), &LedDevice::isStopped, &loop, &QEventLoop::quit);
	// Turn the LEDs off & stops refresh timers
	emit stop();
	loop.exec();

	_ledDevice.reset();

	if (!_ledDeviceThread.isNull())
	{
		if (_ledDeviceThread->isRunning())
		{
			_ledDeviceThread->quit();
			_ledDeviceThread->wait();
			_ledDeviceThread.reset();
		}
	}

	Debug(_log, "LED-Device thread stopped");
	emit isStopped();
}

QString LedDeviceWrapper::getActiveDeviceType() const
{
	QString value = nullptr;
	QMetaObject::invokeMethod(_ledDevice.get(), "getActiveDeviceType", Q_RETURN_ARG(QString, value));
	return value;
}

int LedDeviceWrapper::getLedCount() const
{
	int count = 0;
	QMetaObject::invokeMethod(_ledDevice.get(), "getLedCount", Qt::BlockingQueuedConnection, Q_RETURN_ARG(int, count));
	return count;
}

QString LedDeviceWrapper::getColorOrder() const
{
	QString value;
	QMetaObject::invokeMethod(_ledDevice.get(), "getColorOrder", Qt::BlockingQueuedConnection, Q_RETURN_ARG(QString, value));
	return value;
}

int LedDeviceWrapper::getLatchTime() const
{
	int value = 0;
	QMetaObject::invokeMethod(_ledDevice.get(), "getLatchTime", Qt::BlockingQueuedConnection, Q_RETURN_ARG(int, value));
	return value;
}

bool LedDeviceWrapper::isEnabled() const
{
	return _isEnabled;
}

bool LedDeviceWrapper::isOn() const
{
	return _isOn;
}

void LedDeviceWrapper::initializeDeviceMap()
{
	std::call_once(initFlag, []() {
		// Initialize the map once
#define REGISTER(className) _ledDeviceMap.emplace(QString(#className).toLower(), LedDevice##className::construct);

#include "LedDevice_register.cpp"

#undef REGISTER
	});
}

const LedDeviceRegistry& LedDeviceWrapper::getDeviceMap()
{
	initializeDeviceMap(); // Ensure it is initialized before returning
	return _ledDeviceMap;
}

QJsonObject LedDeviceWrapper::getLedDeviceSchemas()
{
	// make sure the resources are loaded (they may be left out after static linking)
	Q_INIT_RESOURCE(LedDeviceSchemas);

	// read the JSON schema from the resource
	QDir const dir(":/leddevices/");
	QJsonObject result;
	QJsonObject schemaJson;

	for(QString &item : dir.entryList())
	{
		QString const schemaPath(QString(":/leddevices/")+item);
		QString const devName = item.remove("schema-");

		QString data;
		if(!FileUtils::readFile(schemaPath, data, Logger::getInstance("LEDDEVICE")))
		{
			throw std::runtime_error("ERROR: Schema not found: " + item.toStdString());
		}

		QJsonObject schema;
		QPair<bool, QStringList> const parsingResult = JsonUtils::parse(schemaPath, data, schema, Logger::getInstance("LEDDEVICE"));
		if (!parsingResult.first)
		{
			QStringList const errorList = parsingResult.second;
			for (const auto& errorMessage : errorList) {
				Debug(Logger::getInstance("LEDDEVICE"), "JSON parse error: %s ", QSTRING_CSTR(errorMessage));
			}
			throw std::runtime_error("ERROR: JSON schema is wrong for file: " + item.toStdString());
		}


		schemaJson = schema;
		schemaJson["title"] = QString("edt_dev_spec_header_title");

		result[devName] = schemaJson;
	}

	return result;
}
