package org.hyperion.hypercon;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Locale;
import java.util.Vector;

import org.hyperion.hypercon.spec.ColorConfig;
import org.hyperion.hypercon.spec.DeviceConfig;
import org.hyperion.hypercon.spec.EffectEngineConfig;
import org.hyperion.hypercon.spec.ImageProcessConfig;
import org.hyperion.hypercon.spec.Led;
import org.hyperion.hypercon.spec.LedFrameConstruction;
import org.hyperion.hypercon.spec.MiscConfig;
/**
 * The full configuration of Hyperion with sub-items for device, color and miscelanuous items. 
 */
public class LedString {
	
	/** The configuration of the output device */
	public final DeviceConfig mDeviceConfig = new DeviceConfig();

	/** THe configuration of the 'physical' led frame */
	public final LedFrameConstruction mLedFrameConfig = new LedFrameConstruction();
	
	/** The configuration of the image processing */
	public final ImageProcessConfig mProcessConfig = new ImageProcessConfig();
	
	/** The color adjustment configuration */
	public final ColorConfig mColorConfig = new ColorConfig();
	
	/** The miscellaneous configuration (bootsequence, blackborder detector, etc) */
	public final MiscConfig mMiscConfig = new MiscConfig();

	/** The effect engine configuration, containing the Effects */
	public final EffectEngineConfig mEffectEngineConfig = new EffectEngineConfig();
	
	/** The translation of the led frame construction and image processing to individual led configuration */
	public Vector<Led> leds;
	
	/**
	 * Writes the configuration to the given file
	 * 
	 * @param mFilename The absolute filename
	 * 
	 * @throws IOException If unable to write the given file
	 */
	public void saveConfigFile(String mFilename) throws IOException {
		
		try (FileWriter fw = new FileWriter(mFilename)) {
			fw.write("// Automatically generated configuration file for 'Hyperion daemon'\n");
			fw.write("// Generated by: HyperCon (The Hyperion deamon configuration file builder\n");
			fw.write("\n");
			fw.write("{\n");
			
			String deviceJson = mDeviceConfig.toJsonString();
			fw.write(deviceJson + ",\n\n");
			
			String colorJson = mColorConfig.toJsonString();
			fw.write(colorJson + ",\n\n");

			JsonStringBuffer jsonBuf = new JsonStringBuffer(1);

			ledsAppendTo(jsonBuf);
			
			jsonBuf.newLine();
			
			mProcessConfig.appendTo(jsonBuf);

			jsonBuf.newLine();
			
			mMiscConfig.appendTo(jsonBuf);
			
			jsonBuf.newLine();

			mEffectEngineConfig.appendTo(jsonBuf);
			
			jsonBuf.newLine();
			
			jsonBuf.addValue("endOfJson", "endOfJson", true);
			
			fw.write(jsonBuf.toString());
			
			fw.write("}\n");
		} catch (IOException e) {
			throw e;
		}
	}
	
	void ledsAppendTo(JsonStringBuffer pJsonBuf) {
		String ledComment = 
				" The configuration for each individual led. This contains the specification of the area \n" + 
				" averaged of an input image for each led to determine its color. Each item in the list \n" +
				" contains the following fields:\n" +
				" * index: The index of the led. This determines its location in the string of leds; zero \n" +
				"          being the first led.\n" +
				" * hscan: The fractional part of the image along the horizontal used for the averaging \n" +
				"          (minimum and maximum inclusive)\n" +
				" * vscan: The fractional part of the image along the vertical used for the averaging \n" +
				"          (minimum and maximum inclusive)\n";
		pJsonBuf.writeComment(ledComment);
		
		pJsonBuf.startArray("leds");
		for (Led led : leds)
		{
			pJsonBuf.startObject("");
			pJsonBuf.addValue("index", led.mLedSeqNr, false);
			pJsonBuf.addRawValue("hscan", String.format(Locale.ENGLISH, "{ %1$cminimum%1$c : %2$.4f, %1$cmaximum%1$c : %3$.4f }", '"', led.mImageRectangle.getMinX(), led.mImageRectangle.getMaxX()), false);
			pJsonBuf.addRawValue("vscan", String.format(Locale.ENGLISH, "{ %1$cminimum%1$c : %2$.4f, %1$cmaximum%1$c : %3$.4f }", '"', led.mImageRectangle.getMinY(), led.mImageRectangle.getMaxY()), true);
			pJsonBuf.stopObject(led.equals(leds.get(leds.size()-1)));
		}
		pJsonBuf.stopArray();
	}
}
